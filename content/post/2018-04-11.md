+++
date = "2018-04-11T19:15:35+00:00"
title = "Cassandra Database"

+++
... read a bit about the [Cassandra](http://cassandra.apache.org/) database. It's a NoSQL database system that is reputed to be very quick and very robust. Examples of users of this database system are Netflix, Apple, CERN, GitHub, Redit, eBay, etc.

Why Cassandra? It answers some very specific concerns and is just another interesting system to explore. In the CAP theorem, Cassandra answers the AP part, which means availability and partition tolerance. It also means it doesn't provide a strong consistency, as it is only eventually consistent. The way it works for the availability and partition tolerance is through nodes placed on a cluster. All the nodes are communicating together at all time and each node has a part of the data. It could be seen like a raid 5 for a database. When you create a schema, you can decide on how many nodes the table needs to be replicated, and how it will work when querying the table. For instance, you could have a system with 5 nodes (Apple has over 75,000 nodes in its cluster), and say that this new table needs to be on 5 nodes. Then you can tell it that whenever an insert or update is performed, it needs to have a quorum of node committing the change before the call is considered successful. You can then say the same thing about a select, so that whenever a query is performed, it's guaranteed to have all the latest changes.

Cassandra is also very good in terms of big data. It scales linearly with the amount of nodes you put, so the more node, the more queries it can answer. It doesn't slow down because the replication doesn't have to be a full mirror on every node. It might not be useful when you only have a small data set, or that you rarely have concurrent read, but once you get to a point where the insert/update/select are constant and very high volume, it scales all by itself.

Since it is a NoSQL database, you don't get to join tables in your queries. It probably is one of the reason that they can scale the tables on different nodes, since they don't need to have the tables next to one another for joins. They force the complexity on the database user and keep their system simple and scallable. You can however define custom types that can be serialized in a table. You still only get a single row but the complex data is serialized, and that can be nested. It only prevents updates of specific fields, it instead has to receive the full data on updates.

Overall, it's a very impressive system that can answer to so many queries very quickly, without ever losing data. It hardly see any reason not to opt for such a system for bigger applications that need to scale their database access, as it scales way better than any NoSQL and SQL equivalents, while making sure to never lose any data. Furthermore, although they are not consistent, the strategies you can apply on the queries can force some tables to be consistent in exchange of an increased latency, which is a very good option to have.