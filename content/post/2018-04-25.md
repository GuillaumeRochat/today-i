+++
date = "2018-04-25T19:57:28-04:00"
title = "Promise vs Ayns/Await Memoization"

+++
... fiddled a bit with some promises I refactored with async/await. The special case for those promises is that they had some form of memoization. The concept for the function was that it could be called several times with the same parameters but since the process is costly and doesn't change on the same process, it's useless to redo everything. Furthermore, the process is async and involves some heavy memory usage at some point.

The initial trick I did with promises is that whenever it would be called for the first time, it would store the promise chain for the given parameter and then return it. The second time, it would return the same promise chain, but since it would already be resolve, the very last result would be returned. Intuitively it's interesting because it's not changing what's returned at all, it always return the promise chain, and it will always continue on the caller side once it's entirely resolved.

I then tried to rewrite that concept using async/await. It's actually entirely different because you really cannot store the whole promise chain, you store the result only, just like with sync function. I found it sad somehow that the concept of keeping a chain of requirements and the resolve of those requirements couldn't be kept, and that we were back to simply keeping the results of the computing in reference. However, it became much cleaner to read. Does it change anything in terms for sequence in which the calls are performed? No, not really, it just changes where we wait for the call to finish, we don't return right away with a method that will eventually complete, but the order is the same.

The big win from async/await for promises is that we don't keep all the chain of references of all the callbacks and therefore don't keep more references in memory of whatever's not needed. It might sound stupid but one of the most annoying memory leaks I had in NodeJS comes from chains of promises looping and constantly referencing the ones above. The biggest issue we had was with a promise that had a finally that would recall the same method, but finally, as opposed to catch or the last then, don't start over a new chain, they keep the reference to the scope, so we were only extending the chain after every finally, never really resolving the chain entirely (that was with Bluebird a few years back). With async/await, that cannot happen because we don't keep references to the context with callbacks (unless under the roof that's what it always does in which case it can still be a problem but hidden from the coders...). All in all, async/await is a very nice way to write things even if we can't always use it (such as with forEach that are better of with Promise.each).