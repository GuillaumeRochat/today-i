+++
date = "2018-01-28T16:29:06+00:00"
title = "Elasticsearch"

+++
... learned a bit more about [Elasticsearch](https://www.elastic.co/), more specifically about the index and mappings. It all started from a simple issue where upon querying an execution UUID to get the related logs, we'd get the logs from another execution as well.

My initial though was that we had an issue with our software that was getting the logs from the first query and a specific query and ended up accidentally merging them. However, the result displayed was taken straight out of Elasticsearch API, without any alteration from our part. Upon reviewing when it happened, I noticed that it was only when a subset of the UUID matched. Let say we have the UUIDs "abc123-baba" and "def456-baba", that would match because of the "baba". But why?

When we send data to Elasticsearch, it does a [Dynamic Mapping](https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-mapping.html), which is rather basic. If it gets a string, it's mapped to a type text and it goes through the default text analyzer. If it gets a number, it's indexed as a number, etc. The default analyzer, when receiving a string, normalizes it to build an index. It splits the words on some characters and lower case the strings to index them. Which means when we sent the UUID "ABC123-BABA", it indexed it as "abc123" and "baba".

When we query with a [Match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html) on the text field, it does the same thing, it takes the query it received, splits on some characters and normalizes the query. So, by asking for UUID "abc123-baba", Elasticsearch was going through the "abc123" and "baba" indexes and returned all results. By default, a match uses the "or" operator. Therefore, we were getting all the results, not just those matching both "abc123" and "baba". Adding the operator "and" is an option, but as we are working with UUIDs, we actually have unique identifiers that we always want to match exactly. A Match is rather resource intensive for such query.

The other option is to perform a [Term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html) query instead. It is much faster simply by the fact that it only does an exact match and does not require going through the analyzer for the strings and checking multiple index. However, for a Term query to be doable, the field must be of type keyword in the index, and the only way to specify a type for a field is to do an [Explicit Mapping](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html#_explicit_mappings). It allows the user to specify more clearly the type and role of each data sent to Elasticsearch, optimizing its usage. We can specify that UUID is a type "keyword", and then query it with a Term to get only what we are looking for, without having to worry about partial matches and slow query.