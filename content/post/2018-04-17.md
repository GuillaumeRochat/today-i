+++
date = "2018-04-17T17:15:20-04:00"
title = "PHP Traits and Composition"

+++
... discussed about design a surrounding traits in PHP. The way they work, traits are really just a way to reuse functions in different classes without having to recode them or extend another class. It makes it possible to do multiple inheritance of some sort. For instance, you might want to extend an abstract class that requires a behavior, but half of the classes that will extend that abstract class will have the exact same implementation of a method. You could use a trait to code that method once and use the traits in all the corresponding class.

The only way I really like to use traits is to compose an object that won't have a lot of internal behavior. We used it to create methods to easily serialize/deserialize objects to arrays or json, to easily run through the properties for validation, etc. It makes sens because the class we are building is a behavior less class, and the traits are only adding something to be used from outside. An example of a good trait would be to add a stringify method to an object.

The other option is to add internal methods, and that is less interesting, maybe even more cumbersome. For instance, we had translators that would transforms different objects to something we could insert in the database. Depending on the nature of the objects, we had to transform some stuff and not some other. We tried creating one class for each specific object with a trait containing all the methods needed for almost every object. It made it possible to compose the different methods for the different objects. Sounds good so far, but once you have to unit test everything, it becomes a mess, because you cannot mock your interaction, you basically have to make sure the trait behaves correctly every time. It breaks the composition part by tying the classes together.

Using traits for internal behaviors made it harder to unit test well. A trait that adds a stringify is really easy to test, same for serialization/deserialization. You actually don't use that trait internally so there isn't really anything to test. As soon as we have internal behaviors to reuse a lot, it's much simpler to just use multiple simple classes and compose them together. Yes it requires a lot more of dependencies up front, but it's simpler to reuse those classes and easier to validate the internal behavior of whatever you are building, as you can easily mock and test the class it's using.

As you can see, I'm really more of a composition over inheritance. I actually don't see a lot of use case for inheritance that can't be done with composition or where composition would be a weaker solution. Sure, sometimes we want to type for a specific base class, but when we need to do that, an interface is a better alternative. Sure, an abstract class can provide some basic behavior and then the child class can add some specific details to that parent class behavior, but usually it becomes a burden as soon as a child class differs too much to work with the parent class and needs an almost full rewrite. An interface doesn't bind behaviors but still enforces some methods. But still, that's in a highly OOP world. As soon as I can go for more functional paradigms I do because I also find them much stronger to compose behaviors. After all, that's what we want, to compose behaviors together to form a stream of information that eventually produce the wanted stream of output.