+++
date = "2018-01-10T18:41:23+00:00"
title = "Stereotype Threat and Event Sourcing"

+++
... started out with a podcast on [Stereotype Threat](https://www.npr.org/2015/10/06/444213368/an-ace-up-the-poker-stars-sleeve-the-surprising-upside-of-stereotypes), and learned about this concept where people in a given situation feel at risk of confirming a stereotype about their social group. It has been proven to have negative impacts on the performance of individuals who belong to negatively stereotyped groups.

Then, I went on to read about [Event Sourcing](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing), [CQRS](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs) and [Eventual Consistency](https://msdn.microsoft.com/library/dn589800.aspx). CRQS is a very interesting pattern where the write and the read of data are entirely separate, each with their own mechanism and ways to handle the data, even to a point where the data store could be different. The good side of this concept is that the endpoint can better optimize for what's it about, rather than having to compromise to accommodate for other things. For instance, a read endpoint could have a data store specially made to be as quick as possible to read the data, while the write endpoint would be optimized to be the most granular in the changes it can make while keeping a very high consistency and stability, to the detriment of speed.

Event Sourcing is a pattern I have been trying out in a Proof of Concept. It is widely used in CQRS but can live on its own. The concept is that each command or event that takes place is saved, and the events become the source of truth, as opposed to the data store. In a true Event Sourcing system, you could destroy the database and rebuild it exactly as it was only from events. This means that the events are very important and the database can be secondary. It also means that everything that takes place in the system is logged, so you always know what comes from where and who did it, etc.

Lastly, Eventual Consistency is a state in which you might get in such architecture. Because the events are the source of truth, they need to spread to every little service and store until the state is consistent across the board. In this case, the consistency is not guaranteed at all time, but the eventual consistency is. The thing about eventual consistency is you might think you are not doing, but when you are synchronizing data from one system to another, that's exactly what this is, just at a different scale than with events.

I also watched a [video where Martin Fowler explained the differences between 4 types of event-driven systems](https://www.youtube.com/watch?v=STKCRSUsyP0). The last two systems were Event Sourcing and CQRS, so not much to say about that, and the very first one wasn't interesting enough for me to remember. However, the second one was interesting because it was talking about different services that would keep a copy of the data they need to operate. So, rather than having to query other systems to get what they need to work, and being dependent on the availability of other systems, it would duplicate that data. The interesting part is that we might believe it is not something we do, but it's actually a part of a pattern we have. When we discussed about microservices, the point of keeping the data in the different microservices was being pushed against. But, when looking at the concept of synchronizing external services we consume, that's exactly what we are doing, for instance synchronizing Google Calendar to a CRM so that in the event Google Calendar is unavailable, the CRM can still work.